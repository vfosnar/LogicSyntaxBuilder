reference:
use build/dflipflop_32bit.json as dflipflop_32bit
use build/adder_8bit.json as adder_8bit


define:
in clk[1]
in in_BUS[32]
is_in_BUS_1_vec[32]
is_in_BUS_2_vec[32]
is_in_BUS_4_vec[32]
is_in_BUS_8_vec[32]
is_in_BUS_16_vec[32]
is_in_BUS_32_vec[32]
is_in_BUS[33]
out out_BUS[32]
out_bus_8[32]
out_bus_88[32]
out_bus_16[32]
out_bus_32[32]

out out_dff[32]; only debug; should be normal

; 0 SET
; 1 ADD
; 2 SUB
; 3 AND
; 4 OR
; 5 XOR
; 6 ROL
; 7 ROR
; 8 SHL
; 9 SHR
; A OUT
; B INC - does not set carry
; C DEC
; D NOT
in ctrl_8[14]
act_ctrl_8[1]
in ctrl_88[14]
act_ctrl_88[1]
in ctrl_16[14]
act_ctrl_16[1]
in ctrl_32[14]
act_ctrl_32[1]
in ctrl_clear[1]
dont_clear[1]

; collecton of signals
in_dff[32]

; signals with different range
in_dff8[32]
in_dff88[32]
in_dff16[32]
in_dff32[32]

; define vectors
; 8 bits
SET_in_dff8[8]
ADD_in_dff8[8]
SUB_in_dff8[8]
AND_in_dff8[8]
OR_in_dff8[8]
XOR_in_dff8[8]
ROL_in_dff8[8]
ROR_in_dff8[8]
SHL_in_dff8[8]
SHR_in_dff8[8]
OUT_in_dff8[8]
INC_in_dff8[8]
DEC_in_dff8[8]
NOT_in_dff8[8]
; 8-16 bits
SET_in_dff88[8]
ADD_in_dff88[8]
SUB_in_dff88[8]
AND_in_dff88[8]
OR_in_dff88[8]
XOR_in_dff88[8]
ROL_in_dff88[8]
ROR_in_dff88[8]
SHL_in_dff88[8]
SHR_in_dff88[8]
OUT_in_dff88[8]
INC_in_dff88[8]
DEC_in_dff88[8]
NOT_in_dff88[8]
; 16 bits

; 32 bits

KEEP_in_dff32[32]

; define data vectors
; 8 bits
data_SET_in_dff8[8]
data_ADD_in_dff8[8]
data_SUB_in_dff8[8]
data_AND_in_dff8[8]
data_OR_in_dff8[8]
data_XOR_in_dff8[8]
data_ROL_in_dff8[8]
data_ROR_in_dff8[8]
data_SHL_in_dff8[8]
data_SHR_in_dff8[8]
data_OUT_in_dff8[8]
data_INC_in_dff8[8]
data_DEC_in_dff8[8]
data_NOT_in_dff8[8]
; 8-16 bits
data_SET_in_dff88[8]
data_ADD_in_dff88[8]
data_SUB_in_dff88[8]
data_AND_in_dff88[8]
data_OR_in_dff88[8]
data_XOR_in_dff88[8]
data_ROL_in_dff88[8]
data_ROR_in_dff88[8]
data_SHL_in_dff88[8]
data_SHR_in_dff88[8]
data_OUT_in_dff88[8]
data_INC_in_dff88[8]
data_DEC_in_dff88[8]
data_NOT_in_dff88[8]
; 16 bits

; 32 bits

; define vectors needed by smaller operations
; 8 bits
proc_data_SUB_in_dff8[8]
proc_data_SUB_in_dff88[8]
; 8-16 bits

; 16 bits

; 32 bits

assign:
; collect signals into one
in_dff <= or in_dff8 in_dff88 in_dff16 in_dff32
out_BUS <= or out_bus_8 out_bus_88 out_bus_16 out_bus_32

is_in_BUS_1_vec <= xnor in_BUS 1
is_in_BUS_2_vec <= xnor in_BUS 2
is_in_BUS_4_vec <= xnor in_BUS 4
is_in_BUS_8_vec <= xnor in_BUS 8
is_in_BUS_16_vec <= xnor in_BUS 16
is_in_BUS_32_vec <= xnor in_BUS 32

is_in_BUS[1] <= and is_in_BUS_1_vec
is_in_BUS[2] <= and is_in_BUS_2_vec
is_in_BUS[4] <= and is_in_BUS_4_vec
is_in_BUS[8] <= and is_in_BUS_8_vec
is_in_BUS[16] <= and is_in_BUS_16_vec
is_in_BUS[32] <= and is_in_BUS_32_vec

; ##########   define signals with different ranges   ##########
in_dff8[0:8] <= or SET_in_dff8 ADD_in_dff8 SUB_in_dff8 AND_in_dff8 OR_in_dff8 XOR_in_dff8 ROL_in_dff8 ROR_in_dff8 SHL_in_dff8 SHR_in_dff8 OUT_in_dff8 INC_in_dff8 DEC_in_dff8 NOT_in_dff8
in_dff88[8:16] <= or SET_in_dff88 ADD_in_dff88 SUB_in_dff88 AND_in_dff88 OR_in_dff88 XOR_in_dff88 ROL_in_dff88 ROR_in_dff88 SHL_in_dff88 SHR_in_dff88 OUT_in_dff88 INC_in_dff88 DEC_in_dff88 NOT_in_dff88
; ...
; dont forgot to keep signal
in_dff32[0:32] <= KEEP_in_dff32

; boolean vector if any of control signals are active
act_ctrl_8 <= or ctrl_8
act_ctrl_88 <= or ctrl_88
act_ctrl_16 <= or ctrl_16
act_ctrl_32 <= or ctrl_32

; fix missing data
in_dff8[8:32] <= and act_ctrl_8 out_dff[8:32]

in_dff88[0:8] <= and act_ctrl_88 out_dff[0:8]
in_dff88[16:32] <= and act_ctrl_88 out_dff[16:32]

in_dff16[16:32] <= and act_ctrl_16 out_dff[16:32]

; ##########   enable signals with control signal   ##########
; 8 bits
SET_in_dff8 <= and ctrl_8[0] data_SET_in_dff8
ADD_in_dff8 <= and ctrl_8[1] data_ADD_in_dff8
SUB_in_dff8 <= and ctrl_8[2] data_SUB_in_dff8
AND_in_dff8 <= and ctrl_8[3] data_AND_in_dff8
OR_in_dff8 <= and ctrl_8[4] data_OR_in_dff8
XOR_in_dff8 <= and ctrl_8[5] data_XOR_in_dff8
ROL_in_dff8 <= and ctrl_8[6] data_ROL_in_dff8
ROR_in_dff8 <= and ctrl_8[7] data_ROR_in_dff8
SHL_in_dff8 <= and ctrl_8[8] data_SHL_in_dff8
SHR_in_dff8 <= and ctrl_8[9] data_SHR_in_dff8
OUT_in_dff8 <= and ctrl_8[10] data_OUT_in_dff8
INC_in_dff8 <= and ctrl_8[11] data_INC_in_dff8
DEC_in_dff8 <= and ctrl_8[12] data_DEC_in_dff8
NOT_in_dff8 <= and ctrl_8[13] data_NOT_in_dff8
; 8-16 bits (88)
SET_in_dff88 <= and ctrl_88[0] data_SET_in_dff88
ADD_in_dff88 <= and ctrl_88[1] data_ADD_in_dff88
SUB_in_dff88 <= and ctrl_88[2] data_SUB_in_dff88
AND_in_dff88 <= and ctrl_88[3] data_AND_in_dff88
OR_in_dff88 <= and ctrl_88[4] data_OR_in_dff88
XOR_in_dff88 <= and ctrl_88[5] data_XOR_in_dff88
ROL_in_dff88 <= and ctrl_88[6] data_ROL_in_dff88
ROR_in_dff88 <= and ctrl_88[7] data_ROR_in_dff88
SHL_in_dff88 <= and ctrl_88[8] data_SHL_in_dff88
SHR_in_dff88 <= and ctrl_88[9] data_SHR_in_dff88
OUT_in_dff88 <= and ctrl_88[10] data_OUT_in_dff88
INC_in_dff88 <= and ctrl_88[11] data_INC_in_dff88
DEC_in_dff88 <= and ctrl_88[12] data_DEC_in_dff88
NOT_in_dff88 <= and ctrl_88[13] data_NOT_in_dff88
; 16 bits

; 32 bits

; ##########   dont forgot the keep signal   ##########
dont_clear <= nor ctrl_clear ctrl_8 ctrl_88 ctrl_16 ctrl_32
KEEP_in_dff32 <= and dont_clear out_dff

; ##########   assign data   ##########
; 8 bits
; SET
data_SET_in_dff8 <= in_BUS[0:8]
; ADD
adder_8bit
{
    to _a <= out_dff[0:8]
    to _b <= in_BUS[0:8]
    exp data_ADD_in_dff8 <= _s
}
; SUB
adder_8bit
{
    to _a <= nor in_BUS[0:8]
    to _b <= 1
    exp proc_data_SUB_in_dff8 <= _s
}
adder_8bit
{
    to _a <= proc_data_SUB_in_dff8[0:8]
    to _b <= out_dff[0:8]
    exp data_SUB_in_dff8 <= _s
}
; AND
data_AND_in_dff8 <= and out_dff[0:8] in_BUS[0:8]
; OR
data_OR_in_dff8 <= or out_dff[0:8] in_BUS[0:8]
; XOR
data_XOR_in_dff8 <= xor out_dff[0:8] in_BUS[0:8]
; ROL
data_ROL_in_dff8[0] <= and out_dff[7] is_in_BUS[1]
data_ROL_in_dff8[1:8] <= and out_dff[0:7] is_in_BUS[1]
; ROR
data_ROR_in_dff8[0:7] <= and out_dff[1:8] is_in_BUS[1]
data_ROR_in_dff8[7] <= and out_dff[0] is_in_BUS[1]
; SHL
data_SHL_in_dff8[1:8] <= and out_dff[0:7] is_in_BUS[1]
; SHR
data_SHR_in_dff8[0:7] <= and out_dff[1:8] is_in_BUS[1]
; OUT
data_OUT_in_dff8 <= out_dff[0:8]
out_bus_8[0:8] <= and ctrl_8[10] out_dff[0:8]

; INC
adder_8bit
{
    to _a <= out_dff[0:8]
    to _b <= 1
    exp data_INC_in_dff8 <= _s
}
; DEC
adder_8bit
{
    to _a <= out_dff[0:8]
    to _b <= 255
    exp data_DEC_in_dff8 <= _s
}
; NOT
data_NOT_in_dff8 <= nor out_dff[0:8]
; #####   8-16 bits (88)   #####
data_SET_in_dff88 <= in_BUS[8:16]
; ADD
adder_8bit
{
    to _a <= out_dff[8:16]
    to _b <= in_BUS[0:8]
    exp data_ADD_in_dff88 <= _s
}
; SUB
adder_8bit
{
    to _a <= nor in_BUS[0:8]
    to _b <= 1
    exp proc_data_SUB_in_dff88 <= _s
}
adder_8bit
{
    to _a <= proc_data_SUB_in_dff88[0:8]
    to _b <= out_dff[8:16]
    exp data_SUB_in_dff88 <= _s
}
; AND
data_AND_in_dff88 <= and out_dff[8:16] in_BUS[0:8]
; OR
data_OR_in_dff88 <= or out_dff[8:16] in_BUS[0:8]
; XOR
data_XOR_in_dff88 <= xor out_dff[8:16] in_BUS[0:8]
; ROL
data_ROL_in_dff88[0] <= and out_dff[15] is_in_BUS[1]
data_ROL_in_dff88[1:8] <= and out_dff[8:15] is_in_BUS[1]
; ROR
data_ROR_in_dff88[0:7] <= and out_dff[9:16] is_in_BUS[1]
data_ROR_in_dff88[7] <= and out_dff[8] is_in_BUS[1]
; SHL
data_SHL_in_dff88[1:8] <= and out_dff[8:15] is_in_BUS[1]
; SHR
data_SHR_in_dff88[0:7] <= and out_dff[9:16] is_in_BUS[1]
; OUT
data_OUT_in_dff88 <= out_dff[8:16]
out_bus_88[0:8] <= and ctrl_88[10] out_dff[8:16]

; INC
adder_8bit
{
    to _a <= out_dff[8:16]
    to _b <= 1
    exp data_INC_in_dff88 <= _s
}
; DEC
adder_8bit
{
    to _a <= out_dff[8:16]
    to _b <= 255
    exp data_DEC_in_dff88 <= _s
}
; NOT
data_NOT_in_dff88 <= nor out_dff[8:16]
; #####   16 bits   #####

; #####   32 bits   #####


dflipflop_32bit
{
    to _clk <= clk
    to _inp <= in_dff
    exp out_dff <= _Q
}